# 试题4
> ### 第一题
```go
// 第一步执行r = n +1，接着执行第二个 defer，由于此时 f() 未定义，引发异常，随即执行第一个 defer
// 异常被 recover()，程序正常执行，最后 return。
//func f(n int) (r int) {
//	defer func() {
//		r += n
//		// 这里对异常进行恢复,正常输内容
//		recover()
//	}()
//
//	var f func()
//	// 由于此时的f() 未定义引发异常panic
//	defer f()
//	f = func() {
//		r += 2
//	}
//
//	return n + 1
//}
//
//func main() {
//	fmt.Println(f(3)) // 7
//}
````
> ### 第二题
```go
// range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a
// 因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，
// 而非修改后的值。
//func main() {
//	var a = [5]int{1, 2, 3, 4, 5}
//	var r [5]int
//
//	for i, v := range a {
//		if i == 0 {
//			a[1] = 12
//			a[2] = 13
//		}
//		r[i] = v
//	}
//
//	//// 想要 a 和 r 一样输出
//	//for i, v := range &a {
//	//	if i == 0 {
//	//		a[1] = 12
//	//		a[2] = 13
//	//	}
//	//	r[i] = v
//	//}
//
//	fmt.Println("r = ", r) // r =  [1 2 3 4 5]
//	fmt.Println("a = ", a) // a =  [1 12 13 4 5]
//}
```