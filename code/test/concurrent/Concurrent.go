package concurrent

import "os"
/*
进程空间[01.进程虚拟内存与物理内存.png]:
	用户空间:         0 ~ TASK_SIZE
	内核空间: TASK_SIZE ~ 2^32/2^64

	TASK_SIZE 相当于 用户空间 和 内核空间 的分界线, 是一个特定的常数, 由计算机的体系结构决定

	每个用户进程分配到的虚拟内存总是在用户空间, 每个用户进程 独立, 互相不可见

	内核会把进程的虚拟内存划分为若干页（page），而物理内存单元的划分由CPU负责。
	一个物理内存单元被称为一个页框（page frame）。
	不同进程的大多数页都会与不同的页框相对应, 个别会有不同页对应同一个框的情况

	用户进程无法直接访问内核空间，也无法随意指使内核去做它能做的一些事 !!!
	但是为了使用户进程能够使用操作系统更底层的功能，内核会暴露出一些接口以供它们使用，
	这些接口是用户进程使用内核功能（包括操纵计算机硬件）的唯一手段，也是用户空间和内核空间之间的一座桥梁。

	用户进程使用这些接口的行为称为 系统调用 !!!!
	不过在很多时候“系统调用”这个词也指内核提供的这些接口。注意，虽然系统调用也是由函数呈现的，但它与普通的函数有明显的区别。
	系统调用是向内核空间发出的一个明确请求，而普通函数只是定义了如何获取一个给定的服务。
	系统调用会导致内核空间中数据的存取和指令的执行，而普通函数却只能在用户空间中有所作为。

	当然，如果在一个函数的函数体中包含了系统调用，那么它的执行也将涉及对内核空间的访问，但是这种访问仍然是通过函数体内的系统调用来完成的

系统调用[02.系统调用过程.png]:
	系统调用的两个概念:
		- 用户态
		- 内核态
	为了保证操作系统的稳定和安全，
	内核依据由CPU提供的、可以让进程驻留的特权级别建立了两个特权状态 —— 内核态 和 用户态。
	在大部分时间里，CPU都处于用户态，这时CPU只能对用户空间进行访问。
	换言之，CPU在用户态下运行的用户进程是不能与内核接触的。
	当用户进程发出一个系统调用的时候，内核会把CPU从用户态切换到内核态，而后会让CPU执行对应的内核函数。
	CPU在内核态下是有权限访问内核空间的，这就相当于用户进程可以通过系统调用使用内核提供的功能。
	当内核函数执行完毕后，内核会把CPU从内核态切换回用户态，并把执行结果返回给用户进程

进程的切换和调度:
	Linux操作系统也可以凭借CPU的威力快速地在多个进程之间进行切换，这也称为进程间的上下文切换。如此会产生多个进程同时运行的假象，
	而每个进程都会认为自己独占了CPU，这就是多任务操作系统这个称谓的由来。不过，无论切换速度如何，在同一时刻正在运行的进程仅会有一个。

	切换CPU正在运行的进程是需要付出代价的, 切换当前进程, 需要保留当前进程的状态, 再次恢复当前进程要保证能够准确恢复之前所有信息, 这个过程是耗时的

socket:
	socket，常译为套接字，也是一种IPC(进程通信)方法。但是与其他IPC方法不同的是，它可以通过网络连接让多个进程建立通信并相互传递数据，
	这使得通信双方是否在同一台计算机上变得无关紧要。

	大多数操作系统都包含socket接口的实现，主流以及新兴的编程语言也都支持socket

	socket 类型有很多, 主要分为:
		- SOCK_STREAM 		// 常见
		- SOCK_DGRAM  		// 常见
		- SOCK_RAW	  		// 更底层
		- SOCK_SEOPACKET 	// 新技术

	形式:
		- 数据报
			数据报为数据形式意味着数据接收方的socket接口程序可以意识到数据的边界并会对它们进行切分，这样就省去了接收方的应用程序寻找数据边界和切分数据的工作量
		- 字节流
			以字节流为数据形式的数据传输实际上传输的是一个字节接着一个字节的串，我们可以把它想象成一个很长的字节数组。
			一般情况下，字节流并不能体现出哪些字节属于哪个数据包。因此，socket接口程序是无法从中分离出独立的数据包的

		socket接口程序与 TCP/IP 协议栈的实现程序一样, 是 Linux 系统内核的一部分

基于 TCP/IP 的 socket 通信:
	为了使用 Go 实现 服务端 与 客户端 程序, 需要使用标准库 net 中的 API
	- func Listen(net, laddr string) (Listener, error)
	第一个参数代表以何种协议监听给定的地址, Go中用一些字符串字面量来表示 如: tcp/tcp6/tcp4/udp/udp4/unix ....
	第二个参数表示当前程序再网络中的标识, 格式为 host:port

	listener, err := net.Listen("tcp", "127.0.0.1:8080")

	conn, err := listener.Accept()

	客户端:
	dail 拨号
	conn, err := net.Dail("tcp", "127.0.0.1:8085")
	conn, err := net.DialTimeout("tcp", "127.0.0.1:8085", 2*time.Second)
*/

func Concurrent() {
	os.Getpid() // 获取进程 pid
	os.Getppid() // 获取进程父 pid
}