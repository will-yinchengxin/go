package eight

/*
回溯：
	• 回溯的处理过程是⼀个穷举（或者叫枚举）的过程。枚举所有的解，找出其中满⾜期望的可
		⾏解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程归纳为多
		阶段决策模型。每个阶段的决策会对应多个选择，从可选的选择列表中，任意选择⼀个，然
		后继续进⾏下⼀个阶段的决策。

	• 整个决策的过程，如果⽤图来形象话表示的话，就是⼀棵决策树。回溯穷举所有解来查找可
		⾏解的过程，就是在决策树中进⾏遍历的过程。遍历过程中记录的路径就是解。

	• 回溯⼀般使⽤递归来实现，递归树就跟决策树完全⼀样。递的过程进⾏函数调⽤，对应到递
		归树上为从⼀个节点进⼊它的⼦节点，归的过程进⾏函数调⽤返回，对应到递归树上是从⼦
		节点返回上⼀层节点

	################### 回溯模版 ###################
	return = [] // 结果集
	defer backtrack(可选列表，决策阶段，路径) {
		if 满足结束条件(所有决策都已完成 或 得到可行解) { // 终止条件
			if 路径为可行解：{
				result.add(路径)
				return
			}
		}

		for 选择 in	[可选列表]：{   // 回溯
			# 做选择，更改 节点状态
			路径.add(选择)
			可选列表.remove(选择)

			backtrack(可选列表，决策阶段+1，路径)

			# 撤销选择，恢复 节点状态
			路径.remove(选择)
			可选列表.add(选择)
		}
	}

	################### 递归模版 ###################
	 def recur(参数) {
		 递归结束条件 # 最⼩⼦问题
		 …前置逻辑...
		 recur(参数); #⼦问题
		 是否有现场需要⼿动恢复（全局变量）
		 ...后置逻辑...
	}

	################### 核心问题 ###################
	- 发现回溯
	- 定义多阶段决策
	- 找出可选择列表
	- 开始回溯
*/
