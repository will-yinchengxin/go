package four

/*
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0, F(1)= 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
*/
const mod = 1000000007
var helpSeli []int

func fib(n int) int {
	helpSeli = make([]int, n+1)
	return fib_r(n)
}
func fib_r(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	if helpSeli[n] != 0 {
		return helpSeli[n]
	}
	helpSeli[n] = (fib_r(n-1) + fib_r(n-2)) % mod
	return helpSeli[n]
}
/*
这里为什么是 1000000007 取模呢?
	放置在 + 过程数字溢出, int32 范围 -2^31 ~ 2^31 - 1(-2147483648 ~ 2147483647)
	1000000007 位数与 2147483648 位数相同, 均为 10 位, 使 (fib_r(n-1) + fib_r(n-2)) 和 小于 2147483648 的一半( < 1073741824)

时间复杂度(递推公式 / 递归树) 空间复杂度?
	此时 时间复杂度 与 空间复杂度 与树的 节点个数 以及 树的高度 有关(分析过程见图解: 递归_二叉树.JPG)
	- 高度: (n/2 ~ n) // 空间复杂度为 max 值, 因为与函数调用栈有关, 即为 n
	- 节点个数: (2^(n/2) - 1) ~ (2^n - 1) // 时间复杂度

	那么也就可以理解为什么没有备忘录的情况下会超时, 2^10 = 1024, 1024^3 就会非常大为 10 亿左右, 经过 10 次左右调用才有结果

那么使用了备忘录后的时间复杂度和空间复杂度?
	此时的 时间复杂度 因为有备忘录的记录, 此时的只有最左边的长度有关, 可能会关联几个多余的节点, 利用剪枝, 以及约数, 约为 n 了,
		就从指数级别变为了线性级别的

	空间复杂度 不变...
*/